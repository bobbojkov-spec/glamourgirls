import { NextRequest, NextResponse } from 'next/server';
import pool, { getPool } from '@/lib/db';
import { generateSEOEnhanced, calculateSEOStatus } from '@/lib/seo/generate-seo-enhanced';
import { requireAdminApi } from '@/app/api/admin/_auth';

// GET - Get SEO data for an actress
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { error } = await requireAdminApi(request);
  if (error) return error;
  try {
    const { id } = await params;
    const actressId = parseInt(id);

    if (isNaN(actressId)) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 });
    }

    // Fetch actress data (using lowercase column names to match actual database schema)
    const [actressRows] = await pool.execute(
      `SELECT 
        id, nm, firstname, familiq, middlenames, godini, theirman, slug,
        seotitle, metadescription, metakeywords, h1title, introtext,
        ogtitle, ogdescription, ogimage, canonicalurl
       FROM girls WHERE id = ?`,
      [actressId]
    ) as any[];

    if (!actressRows || actressRows.length === 0) {
      return NextResponse.json(
        { error: 'Actress not found' },
        { status: 404 }
      );
    }

    const row = actressRows[0];

    // Fetch timeline events
    const [timelineRows] = await pool.execute(
      `SELECT shrttext as date, lngtext as event 
       FROM girlinfos 
       WHERE girlid = ? 
       ORDER BY ord ASC`,
      [actressId]
    ) as any[];

    // Count gallery images
    const [galleryCountRows] = await pool.execute(
      `SELECT COUNT(*) as count FROM images WHERE girlid = ? AND mytp = 4`,
      [actressId]
    ) as any[];
    const galleryCount = galleryCountRows[0]?.count || 0;

    // Get headshot URL
    const headshotUrl = `/api/actresses/${actressId}/headshot`;

    // Get first gallery image
    const [firstGalleryRows] = await pool.execute(
      `SELECT path FROM images WHERE girlid = ? AND mytp = 4 ORDER BY id ASC LIMIT 1`,
      [actressId]
    ) as any[];
    const firstGalleryImageUrl = firstGalleryRows[0]?.path || null;

    // PostgreSQL returns lowercase column names (no underscores)
    const seoData = {
      seoTitle: row.seotitle || '',
      seoDescription: row.metadescription || '',
      seoKeywords: row.metakeywords || '',
      h1Title: row.h1title || '',
      introText: row.introtext || '',
      ogTitle: row.ogtitle || '',
      ogDescription: row.ogdescription || '',
      ogImageUrl: row.ogimage || '',
      canonicalUrl: row.canonicalurl || '',
      seoStatus: 'red' as 'red' | 'yellow' | 'green',
      autoGenerated: false,
      lastAutoGenerate: undefined,
    };

    // Calculate current status
    const calculatedStatus = calculateSEOStatus(seoData, row.nm);
    seoData.seoStatus = calculatedStatus;

    return NextResponse.json({
      ...seoData,
      metadata: {
        actressName: row.nm,
        galleryCount,
        timelineEventCount: timelineRows.length,
      },
    });
  } catch (error) {
    console.error('Error fetching SEO data:', error);
    return NextResponse.json(
      { error: 'Failed to fetch SEO data' },
      { status: 500 }
    );
  }
}

// POST - Save SEO data
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { error } = await requireAdminApi(request);
  if (error) return error;
  
  // Declare variables outside try block so they're accessible in catch
  let actressId: number | undefined;
  let data: any;
  
  try {
    const { id } = await params;
    actressId = parseInt(id);
    data = await request.json();

    if (isNaN(actressId)) {
      return NextResponse.json({ error: 'Invalid ID' }, { status: 400 });
    }

    // Calculate SEO status
    const seoStatus = calculateSEOStatus(data);

    // Update SEO data using a transaction to ensure it commits
    // Use lowercase column names to match actual database schema
    const pgPool = getPool();
    const client = await pgPool.connect();
    try {
      await client.query('BEGIN');
      
      // Try with introText first
      // Use lowercase column names (no underscores) to match actual database schema
      let updateQuery = `
        UPDATE girls SET
          seotitle = $1,
          metadescription = $2,
          metakeywords = $3,
          h1title = $4,
          introtext = $5,
          ogtitle = $6,
          ogdescription = $7,
          ogimage = $8,
          canonicalurl = $9
        WHERE id = $10
      `;
      
      let updateParams = [
        data.seoTitle || null,
        data.seoDescription || null,
        data.seoKeywords || null,
        data.h1Title || null,
        data.introText || null,
        data.ogTitle || null,
        data.ogDescription || null,
        data.ogImageUrl || null,
        data.canonicalUrl || null,
        actressId,
      ];
      
      try {
        console.log(`üîµ Attempting SEO UPDATE for girl ${actressId} with params:`, updateParams.map((p, i) => `${i + 1}: ${p?.substring?.(0, 30) || p || 'null'}`));
        const result = await client.query(updateQuery, updateParams);
        console.log(`‚úÖ SEO data UPDATE executed for girl ${actressId}, rows affected: ${result.rowCount}`);
        
        if (result.rowCount === 0) {
          console.warn(`‚ö†Ô∏è UPDATE affected 0 rows for girl ${actressId} - girl may not exist`);
        }
        
        await client.query('COMMIT');
        
        // Verify the data was actually saved (after commit)
        // Use lowercase column names (no underscores) to match UPDATE query
        const verifyResult = await client.query(
          `SELECT seotitle, metadescription, h1title, metakeywords, ogtitle, ogdescription, ogimage, canonicalurl, introtext FROM girls WHERE id = $1`,
          [actressId]
        );
        
        if (verifyResult.rows && verifyResult.rows.length > 0) {
          const saved = verifyResult.rows[0];
          // PostgreSQL returns lowercase column names
          console.log(`‚úÖ Verified SEO data saved for girl ${actressId}:`, {
            seoTitle: saved.seotitle?.substring(0, 50) || 'null',
            metaDescription: saved.metadescription?.substring(0, 50) || 'null',
            h1Title: saved.h1title?.substring(0, 50) || 'null',
            metaKeywords: saved.metakeywords?.substring(0, 30) || 'null',
            ogTitle: saved.ogtitle?.substring(0, 30) || 'null',
            canonicalUrl: saved.canonicalurl || 'null',
            hasIntroText: !!saved.introtext,
          });
        } else {
          console.error(`‚ùå SEO data verification failed: No rows returned for girl ${actressId}`);
        }
      } catch (updateError: any) {
        // Log the actual error to see what's wrong
        console.error(`‚ùå SEO UPDATE error for girl ${actressId}:`, {
          code: updateError.code,
          message: updateError.message,
          detail: updateError.detail,
          hint: updateError.hint,
        });
        
        // If introText column doesn't exist, save without it
        if (updateError.code === '42703' || updateError.message?.includes('introtext') || updateError.message?.includes('column') && updateError.message?.includes('does not exist')) {
          console.log(`introtext column doesn't exist, saving without it for girl ${actressId}`);
          
          updateQuery = `
            UPDATE girls SET
              seotitle = $1,
              metadescription = $2,
              metakeywords = $3,
              h1title = $4,
              ogtitle = $5,
              ogdescription = $6,
              ogimage = $7,
              canonicalurl = $8
            WHERE id = $9
          `;
          
          updateParams = [
            data.seoTitle || null,
            data.seoDescription || null,
            data.seoKeywords || null,
            data.h1Title || null,
            data.ogTitle || null,
            data.ogDescription || null,
            data.ogImageUrl || null,
            data.canonicalUrl || null,
            actressId,
          ];
          
          console.log(`üîµ Attempting SEO UPDATE (without introText) for girl ${actressId} with params:`, updateParams.map((p, i) => `${i + 1}: ${p?.substring?.(0, 30) || p || 'null'}`));
          const result = await client.query(updateQuery, updateParams);
          console.log(`‚úÖ SEO data UPDATE executed (without introText) for girl ${actressId}, rows affected: ${result.rowCount}`);
          
          if (result.rowCount === 0) {
            console.warn(`‚ö†Ô∏è UPDATE affected 0 rows for girl ${actressId} - girl may not exist`);
          }
          
          await client.query('COMMIT');
          
          // Verify the data was actually saved (after commit)
          // Use lowercase column names (no underscores) to match UPDATE query
          const verifyResult = await client.query(
            `SELECT seotitle, metadescription, h1title, metakeywords, ogtitle, ogdescription, ogimage, canonicalurl FROM girls WHERE id = $1`,
            [actressId]
          );
          
          if (verifyResult.rows && verifyResult.rows.length > 0) {
            const saved = verifyResult.rows[0];
            // PostgreSQL returns lowercase column names
            console.log(`‚úÖ Verified SEO data saved (without introText) for girl ${actressId}:`, {
              seoTitle: saved.seotitle?.substring(0, 50) || 'null',
              metaDescription: saved.metadescription?.substring(0, 50) || 'null',
              h1Title: saved.h1title?.substring(0, 50) || 'null',
              metaKeywords: saved.metakeywords?.substring(0, 30) || 'null',
              ogTitle: saved.ogtitle?.substring(0, 30) || 'null',
              canonicalUrl: saved.canonicalurl || 'null',
            });
          } else {
            console.error(`‚ùå SEO data verification failed: No rows returned for girl ${actressId}`);
          }
        } else {
          await client.query('ROLLBACK');
          throw updateError;
        }
      }
    } catch (error: any) {
      try {
        await client.query('ROLLBACK');
      } catch (rollbackError) {
        console.error('Error during rollback:', rollbackError);
      }
      throw error;
    } finally {
      client.release();
    }

    return NextResponse.json({
      success: true,
      seoStatus,
      message: 'SEO data saved successfully',
    });
  } catch (error) {
    const err = error as any;
    console.error('Error saving SEO data:', {
      message: err?.message,
      code: err?.code,
      detail: err?.detail,
      hint: err?.hint,
      stack: err?.stack,
      actressId: actressId ?? 'unknown',
      data: data ?? 'not loaded',
    });
    const isProd = process.env.NODE_ENV === 'production';
    const errorMessage = isProd 
      ? 'Failed to save SEO data' 
      : `Failed to save SEO data: ${String(err?.message || err?.detail || err)}`;
    return NextResponse.json(
      {
        error: errorMessage,
        details: isProd ? undefined : {
          code: err?.code,
          message: err?.message,
          detail: err?.detail,
        },
      },
      { status: 500 }
    );
  }
}

