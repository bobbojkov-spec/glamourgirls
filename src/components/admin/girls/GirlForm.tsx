'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { generateSlug } from '@/lib/validations/girl';
import SimpleEditor from '@/components/admin/SimpleEditor';
import SEOFormSectionEnhanced from '@/components/admin/girls/SEOFormSectionEnhanced';
import type { SEOData } from '@/lib/seo/generate-seo-enhanced';
import { Tabs, Button, Upload, Typography, App, Input, Select, Checkbox, Form, Row, Col, Space, Card, Alert } from 'antd';
import { DeleteOutlined, PlusOutlined, UploadOutlined } from '@ant-design/icons';
import type { UploadFile, UploadProps } from 'antd';
import ImageDebugPanel from './ImageDebugPanel';

const { Title, Text } = Typography;
const { useApp } = App;
const { Option } = Select;

interface GirlFormProps {
  onSuccess?: () => void;
  isSubmitting: boolean;
  setIsSubmitting: (value: boolean) => void;
  initialData?: any;
  backHref?: string;
}

export default function GirlForm({ onSuccess, isSubmitting, setIsSubmitting, initialData, backHref = '/admin/girls' }: GirlFormProps) {
  const router = useRouter();
  const { message, modal } = useApp();
  // Use ref (not state) so the submit handler always sees the latest intent synchronously.
  const saveModeRef = useRef<'stay' | 'back'>('stay');
  const formRef = useRef<HTMLFormElement | null>(null);
  
  // Debug: Log initial timeline data
  useEffect(() => {
    console.log(`[GirlForm] initialData received:`, {
      hasTimeline: !!initialData?.timeline,
      timelineType: typeof initialData?.timeline,
      timelineIsArray: Array.isArray(initialData?.timeline),
      timelineLength: Array.isArray(initialData?.timeline) ? initialData.timeline.length : 'N/A',
    });
    
    if (initialData?.timeline) {
      console.log(`[GirlForm] Initial timeline data received: ${Array.isArray(initialData.timeline) ? initialData.timeline.length : 0} events`);
      if (Array.isArray(initialData.timeline)) {
        console.log(`[GirlForm] All timeline events:`, JSON.stringify(initialData.timeline, null, 2));
        if (initialData.timeline.length > 0) {
          console.log(`[GirlForm] First few events:`, initialData.timeline.slice(0, 3));
        }
      } else {
        console.error(`[GirlForm] Timeline is not an array!`, initialData.timeline);
      }
    } else {
      console.warn(`[GirlForm] No timeline data in initialData`);
    }
  }, [initialData?.timeline]);
  
  const [formData, setFormData] = useState({
    name: initialData?.name || '',
    firstName: initialData?.firstName || '',
    lastName: initialData?.lastName || '',
    middleNames: initialData?.middleNames || '',
    era: initialData?.era || 3,
    isNew: initialData?.isNew ?? false,
    hasNewPhotos: initialData?.hasNewPhotos ?? false,
    theirMan: initialData?.theirMan ?? false,
    published: initialData?.published ?? false,
    sources: initialData?.sources || '',
    timeline: (() => {
      const timeline = initialData?.timeline;
      console.log(`[GirlForm useState] Initializing timeline from initialData:`, {
        hasTimeline: !!timeline,
        isArray: Array.isArray(timeline),
        length: Array.isArray(timeline) ? timeline.length : 'N/A',
      });
      
      if (Array.isArray(timeline)) {
        const mapped = timeline.map((event: any, idx: number) => {
          const mappedEvent = {
            ...event,
            _originalIndex: idx, // Add stable identifier for tracking
          };
          return mappedEvent;
        });
        console.log(`[GirlForm useState] Mapped ${mapped.length} timeline events`);
        return mapped;
      }
      console.warn(`[GirlForm useState] Timeline is not an array, using empty array`);
      return [];
    })(),
    images: initialData?.images || [],
    links: initialData?.links || [],
    books: initialData?.books || [],
    biography: initialData?.biography || '',
    alternativeNames: initialData?.alternativeNames || '',
    categories: initialData?.categories || '',
    socialLinks: initialData?.socialLinks || '',
    slug: initialData?.slug || '',
    seo: initialData?.seo || {
      seoTitle: '',
      seoDescription: '',
      seoKeywords: '',
      h1Title: '',
      introText: '',
      ogTitle: '',
      ogDescription: '',
      ogImageUrl: '',
      canonicalUrl: '',
      seoStatus: 'red' as 'red' | 'yellow' | 'green',
      autoGenerated: false,
    },
  });

  // Debug: Log images and timeline when initialData changes
  useEffect(() => {
    if (initialData?.images) {
      console.log('Admin: Initial images received:', initialData.images.length, initialData.images);
    }
    if (initialData?.timeline) {
      console.log('Admin: Initial timeline received:', initialData.timeline.length, 'events');
      console.log('Admin: Timeline events:', initialData.timeline);
    } else {
      console.warn('Admin: No timeline data in initialData!', { 
        hasInitialData: !!initialData,
        timeline: initialData?.timeline 
      });
    }
    
    // Ensure timeline is properly set in formData
    if (initialData?.timeline && Array.isArray(initialData.timeline) && initialData.timeline.length > 0) {
      if (formData.timeline.length === 0) {
        console.warn('Admin: Timeline in initialData but not in formData! Updating...');
        setFormData(prev => ({ ...prev, timeline: initialData.timeline }));
      }
    }
  }, [initialData]);

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [headshotFileList, setHeadshotFileList] = useState<UploadFile[]>([]);
  const [galleryFileList, setGalleryFileList] = useState<UploadFile[]>([]);
  const [activeTab, setActiveTab] = useState('general');
  
  // Debug state (only in development or with ?debug=1)
  const [debugInfo, setDebugInfo] = useState<{
    uploadQueue: Array<{ filename: string; status: 'pending' | 'uploading' | 'storage-uploaded' | 'db-inserted' | 'success' | 'failed'; error?: string; imageId?: number; orderNum?: number }>;
    apiResponses: Array<{ endpoint: string; method: string; status: number; timestamp: number; payload?: any; response?: any; rowsReceived?: number; rowsUpdated?: number; rowsInserted?: number; rowsDeleted?: number; error?: string }>;
  }>({
    uploadQueue: [],
    apiResponses: [],
  });
  
  const isDebugMode = typeof window !== 'undefined' && (
    process.env.NODE_ENV === 'development' || 
    new URLSearchParams(window.location.search).get('debug') === '1'
  );

  // Auto-generate slug from name
  useEffect(() => {
    if (!initialData && formData.name && !formData.slug) {
      setFormData(prev => ({
        ...prev,
        slug: generateSlug(formData.name),
      }));
    }
  }, [formData.name, initialData]);


  const handleChange = (field: string, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  // Normalize timeline orders to continuous sequence (1...N, no duplicates)
  const normalizeTimelineOrders = (timeline: any[]): any[] => {
    if (!Array.isArray(timeline) || timeline.length === 0) return [];
    
    // Sort by current ord (or index), then assign sequential orders
    // Preserve _originalIndex if it exists
    const sorted = [...timeline].sort((a, b) => {
      const ordA = a.ord || 0;
      const ordB = b.ord || 0;
      return ordA - ordB;
    });
    
    return sorted.map((event, index) => ({
      ...event,
      ord: index + 1,
      // Preserve _originalIndex if it exists
      _originalIndex: event._originalIndex !== undefined ? event._originalIndex : index,
    }));
  };

  // Reorder timeline when Order dropdown changes
  const handleTimelineOrderChange = (sortedIndex: number, newOrder: number) => {
    console.log(`[handleTimelineOrderChange] sortedIndex=${sortedIndex}, newOrder=${newOrder}`);
    
    // First, ensure all events have valid ord values and sort
    const timelineWithOrd = formData.timeline.map((event, idx) => ({
      ...event,
      ord: event.ord || (idx + 1),
      _originalIndex: event._originalIndex !== undefined ? event._originalIndex : idx,
    }));
    
    const sortedByOrd = [...timelineWithOrd].sort((a, b) => (a.ord || 0) - (b.ord || 0));
    const totalEvents = sortedByOrd.length;
    
    console.log(`[handleTimelineOrderChange] Total events: ${totalEvents}`);
    console.log(`[handleTimelineOrderChange] Current timeline ord values:`, sortedByOrd.map(e => e.ord));
    
    if (newOrder < 1 || newOrder > totalEvents) {
      console.error(`[handleTimelineOrderChange] Invalid newOrder: ${newOrder}`);
      return;
    }
    
    // Get the event being moved from the sorted array
    const eventToMove = sortedByOrd[sortedIndex];
    if (!eventToMove) {
      console.error(`[handleTimelineOrderChange] Event at sorted index ${sortedIndex} not found`);
      return;
    }
    
    const oldOrder = eventToMove.ord || (sortedIndex + 1);
    console.log(`[handleTimelineOrderChange] Moving event from ord=${oldOrder} to ord=${newOrder}`);
    
    // If order didn't change, do nothing
    if (oldOrder === newOrder) {
      console.log(`[handleTimelineOrderChange] Order unchanged, skipping`);
      return;
    }
    
    // Create new timeline with updated orders
    const newTimeline = sortedByOrd.map((event) => {
      const currentOrd = event.ord || 0;
      
      // Use _originalIndex to identify the event being moved
      const isMovingEvent = event._originalIndex === eventToMove._originalIndex;
      
      if (isMovingEvent) {
        // This is the event being moved
        console.log(`[handleTimelineOrderChange] Moving event: ord ${currentOrd} -> ${newOrder}`);
        return { ...event, ord: newOrder };
      } else if (oldOrder < newOrder) {
        // Moving down: shift events between oldOrder and newOrder up by 1
        if (currentOrd > oldOrder && currentOrd <= newOrder) {
          console.log(`[handleTimelineOrderChange] Shifting event up: ord ${currentOrd} -> ${currentOrd - 1}`);
          return { ...event, ord: currentOrd - 1 };
        }
      } else {
        // Moving up: shift events between newOrder and oldOrder down by 1
        if (currentOrd >= newOrder && currentOrd < oldOrder) {
          console.log(`[handleTimelineOrderChange] Shifting event down: ord ${currentOrd} -> ${currentOrd + 1}`);
          return { ...event, ord: currentOrd + 1 };
        }
      }
      
      return event;
    });
    
    console.log(`[handleTimelineOrderChange] After reordering, ord values:`, newTimeline.map(e => e.ord));
    
    // Normalize to ensure continuous sequence (1...N)
    const normalized = normalizeTimelineOrders(newTimeline);
    console.log(`[handleTimelineOrderChange] After normalization, ord values:`, normalized.map(e => e.ord));
    
    // Preserve _originalIndex in normalized timeline
    // Ensure normalized is an array before mapping
    if (!Array.isArray(normalized)) {
      console.error('[handleTimelineOrderChange] normalized is not an array:', typeof normalized, normalized);
      return;
    }
    
    const normalizedWithIds = normalized.map((event, idx) => {
      if (!event || typeof event !== 'object') {
        console.error('[handleTimelineOrderChange] Invalid event in normalized:', event);
        return null;
      }
      return {
        ...event,
        _originalIndex: event._originalIndex !== undefined ? event._originalIndex : idx,
      };
    }).filter((event): event is any => event !== null);
    
    console.log(`[handleTimelineOrderChange] Final timeline length: ${normalizedWithIds.length}`);
    
    // Ensure we have a valid array before updating state
    if (!Array.isArray(normalizedWithIds)) {
      console.error('[handleTimelineOrderChange] normalizedWithIds is not an array:', typeof normalizedWithIds);
      return;
    }
    
    handleChange('timeline', normalizedWithIds);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Prevent double submission
    if (isSubmitting) {
      return;
    }
    setIsSubmitting(true);
    setErrors({});

    try {
      // Persist current gallery image order as part of Save / Save & Back.
      // This replaces the standalone "Save Order" button.
      const persistGalleryOrderIfNeeded = async (): Promise<
        | { skipped: true }
        | { ok: true; updateCount: number }
        | { ok: false; errorMsg: string; debug?: any }
      > => {
        if (!initialData?.id) return { skipped: true };
        const girlId = Number(initialData.id);
        if (!Number.isFinite(girlId) || girlId < 1) return { skipped: true };

        const images = Array.isArray(formData.images) ? formData.images : [];
        if (images.length === 0) return { skipped: true };

        const orderedImageIds = [...images]
          .sort((a: any, b: any) => {
            const orderA = a.orderNum ?? 999999;
            const orderB = b.orderNum ?? 999999;
            if (orderA !== orderB) return orderA - orderB;
            return a.id - b.id;
          })
          .map((img: any) => Number(img.id))
          .filter((id: number) => Number.isFinite(id) && id > 0);

        if (orderedImageIds.length !== images.length) {
          return {
            ok: false,
            errorMsg: `Reorder payload invalid: expected ${images.length} ids, got ${orderedImageIds.length}`,
            debug: { girlId, orderedImageIds, imagesIds: images.map((i: any) => i.id) },
          };
        }

        const payload = { girlId, orderedImageIds };
        const url = isDebugMode ? '/api/admin/images/reorder?debug=1' : '/api/admin/images/reorder';
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        const contentType = res.headers.get('content-type') || '';
        const rawText = await res.text();
        let responseData: any = {};
        try {
          responseData = rawText ? JSON.parse(rawText) : {};
        } catch {
          responseData = {
            error: 'Non-JSON response from server',
            details: rawText ? rawText.slice(0, 500) : '(empty body)',
          };
        }

        // Debug: Track API response
        if (isDebugMode) {
          setDebugInfo(prev => ({
            ...prev,
            apiResponses: [...prev.apiResponses, {
              endpoint: '/api/admin/images/reorder',
              method: 'POST',
              status: res.status,
              timestamp: Date.now(),
              payload: payload,
              response: responseData,
              rowsReceived: orderedImageIds.length,
              rowsUpdated: responseData.updateCount || 0,
              error: res.ok ? undefined : (responseData.error || 'Unknown error'),
            }],
          }));
        }

        const looksSuccessful =
          res.ok &&
          (responseData?.success === true ||
            (typeof responseData?.updateCount === 'number' && responseData.updateCount > 0));

        if (!looksSuccessful) {
          const errorMsg =
            responseData?.error ||
            responseData?.details ||
            responseData?.message ||
            `HTTP ${res.status} ${res.statusText}${contentType ? ` (${contentType})` : ''}`;
          return {
            ok: false,
            errorMsg,
            debug: {
              status: res.status,
              statusText: res.statusText,
              contentType,
              rawText: rawText ? rawText.slice(0, 1000) : '(empty body)',
              response: responseData,
              payload,
            },
          };
        }

        // Refresh images from server to match DB truth (best-effort)
        try {
          const fetchRes = await fetch(`/api/admin/girls/${girlId}`);
          if (fetchRes.ok) {
            const updatedGirl = await fetchRes.json();
            handleChange('images', updatedGirl.images || []);
          }
        } catch {
          // ignore
        }

        return { ok: true, updateCount: Number(responseData?.updateCount || 0) };
      };

      // Validate links/books: do not allow partially-filled rows to be saved.
      const trim = (v: any) => String(v ?? '').trim();

      const normalizeLinks = (links: any[]) => {
        const normalized = (Array.isArray(links) ? links : []).map((l) => ({
          ...l,
          text: trim(l?.text),
          url: trim(l?.url),
        }));
        const invalidIdx = normalized.findIndex((l) => (l.text && !l.url) || (!l.text && l.url));
        if (invalidIdx !== -1) {
          setActiveTab('sources');
          const rowNum = invalidIdx + 1;
          setErrors({ submit: `Links: row #${rowNum} must have both Link Text and URL (or leave both empty).` });
          setIsSubmitting(false);
          return null;
        }
        // Drop fully-empty rows
        return normalized.filter((l) => l.text || l.url);
      };

      const normalizeBooks = (books: any[]) => {
        const normalized = (Array.isArray(books) ? books : []).map((b) => ({
          ...b,
          title: trim(b?.title),
          url: trim(b?.url),
        }));
        const invalidIdx = normalized.findIndex((b) => (b.title && !b.url) || (!b.title && b.url));
        if (invalidIdx !== -1) {
          setActiveTab('sources');
          const rowNum = invalidIdx + 1;
          setErrors({ submit: `Recommended Books: row #${rowNum} must have both Title and URL (or leave both empty).` });
          setIsSubmitting(false);
          return null;
        }
        // Drop fully-empty rows
        return normalized.filter((b) => b.title || b.url);
      };

      const normalizedLinks = normalizeLinks(formData.links);
      if (normalizedLinks === null) return;
      const normalizedBooks = normalizeBooks(formData.books);
      if (normalizedBooks === null) return;

      // Normalize timeline orders before saving
      // Ensure formData.timeline is an array
      if (!Array.isArray(formData.timeline)) {
        console.error('[Save] formData.timeline is not an array:', typeof formData.timeline, formData.timeline);
        throw new Error('Timeline data is invalid');
      }
      
      const normalizedTimeline = normalizeTimelineOrders(formData.timeline);
      
      // Ensure normalizedTimeline is an array
      if (!Array.isArray(normalizedTimeline)) {
        console.error('[Save] normalizedTimeline is not an array:', typeof normalizedTimeline, normalizedTimeline);
        throw new Error('Timeline normalization failed');
      }
      
      // Strip _originalIndex before saving (it's only for frontend tracking)
      // Preserve id for UPDATE operations
      const timelineForSave = normalizedTimeline.map((event: any) => {
        if (!event || typeof event !== 'object') {
          console.error('[Save] Invalid event in timeline:', event);
          throw new Error('Invalid event in timeline');
        }
        const { _originalIndex, ...eventForSave } = event;
        // Ensure id is a number or null (not undefined)
        if (eventForSave.id !== undefined && eventForSave.id !== null) {
          eventForSave.id = Number(eventForSave.id);
        } else {
          eventForSave.id = null;
        }
        return eventForSave;
      });

      // Ensure all arrays are valid before creating payload
      if (!Array.isArray(timelineForSave)) {
        console.error('[Save] timelineForSave is not an array:', typeof timelineForSave, timelineForSave);
        throw new Error('Timeline data preparation failed');
      }
      
      const payload: any = {
        ...formData,
        links: normalizedLinks,
        books: normalizedBooks,
        timeline: timelineForSave,
      };
      
      // Final validation before sending
      if (!Array.isArray(payload.timeline)) {
        console.error('[Save] payload.timeline is not an array:', typeof payload.timeline, payload.timeline);
        throw new Error('Timeline in payload is invalid');
      }

      // SEO is saved by SEOFormSectionEnhanced via its own API calls.
      // Avoid overwriting SEO with stale/empty values on the main Save.
      if (initialData?.id) {
        delete payload.seo;
      }

      const url = initialData 
        ? `/api/admin/girls/${initialData.id}`
        : '/api/admin/girls';
      
      const method = initialData ? 'PUT' : 'POST';

      // Validate payload before stringifying
      try {
        // Test if payload can be stringified
        JSON.stringify(payload);
      } catch (stringifyError: any) {
        console.error('[Save] Failed to stringify payload:', stringifyError);
        console.error('[Save] Payload structure:', {
          hasTimeline: Array.isArray(payload.timeline),
          timelineType: typeof payload.timeline,
          timelineLength: Array.isArray(payload.timeline) ? payload.timeline.length : 'N/A',
          hasLinks: Array.isArray(payload.links),
          hasBooks: Array.isArray(payload.books),
        });
        throw new Error(`Failed to prepare data for save: ${stringifyError.message}`);
      }

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      const data = await response.json();

      if (!response.ok) {
        if (data.details && Array.isArray(data.details)) {
          setErrors(
            data.details.reduce((acc: Record<string, string>, err: any) => {
              acc[err.path[0]] = err.message;
              return acc;
            }, {})
          );
        } else {
          // Show detailed error message including database error details if available
          let errorMessage = data.error || 'Failed to save';
          if (data.details && typeof data.details === 'object') {
            const detailParts: string[] = [];
            if (data.details.code) detailParts.push(`Code: ${data.details.code}`);
            if (data.details.detail) detailParts.push(`Detail: ${data.details.detail}`);
            if (data.details.hint) detailParts.push(`Hint: ${data.details.hint}`);
            if (detailParts.length > 0) {
              errorMessage += ` (${detailParts.join(', ')})`;
            }
          }
          setErrors({ submit: errorMessage });
        }
        setIsSubmitting(false);
        return;
      }

      // EDIT: by default stay on the page (so you don't lose context/filters).
      // Provide "Save & Back" for returning to the list.
      if (initialData?.id) {
        const reorderResult = await persistGalleryOrderIfNeeded();
        if ((reorderResult as any)?.ok === false) {
          const msg = `Saved, but failed to save image order: ${(reorderResult as any).errorMsg || 'Unknown error'}`;
          message.error(msg);
          console.error('[GirlForm] Reorder-on-save failed:', reorderResult);
          setErrors({ submit: msg });
          setIsSubmitting(false);
          return;
        }

        message.success('Saved');
        if (saveModeRef.current === 'back') {
          // reset so next save doesn't unexpectedly kick you back
          saveModeRef.current = 'stay';
          if (onSuccess) onSuccess();
          else router.push(backHref);
          return;
        }
        setIsSubmitting(false);
        return;
      }

      // CREATE: keep existing behavior
      if (onSuccess) onSuccess();
      else router.push('/admin/girls');
    } catch (error: any) {
      console.error('Error saving girl:', error);
      const errorMessage = error?.message || String(error) || 'An error occurred while saving';
      console.error('Error details:', {
        message: errorMessage,
        stack: error?.stack,
        name: error?.name,
      });
      setErrors({ submit: `Failed to update girl: ${errorMessage}` });
      setIsSubmitting(false);
    }
  };

  const handleHeadshotUpload: UploadProps['customRequest'] = async ({ file, onSuccess, onError, onProgress }) => {
    if (!initialData?.id) {
      message.warning('Please save the entry first before uploading headshot.');
      onError?.(new Error('Entry not saved'));
      return;
    }

    const formData = new FormData();
    formData.append('headshot', file as File);
    formData.append('actressId', initialData.id.toString());

    try {
      const xhr = new XMLHttpRequest();

      // Track upload progress
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          onProgress?.({ percent });
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const data = JSON.parse(xhr.responseText);
          message.success(`Headshot uploaded and processed successfully! Dimensions: ${data.width}x${data.height}px`);
          onSuccess?.(data);
          
          // Invalidate cache to refresh image counts in listing
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('admin-girls-cache-invalidate'));
          }
          
          // Reload page to show new headshot
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        } else {
          const error = JSON.parse(xhr.responseText);
          message.error(`Failed to upload headshot: ${error.error || 'Unknown error'}`);
          onError?.(new Error(error.error || 'Upload failed'));
        }
      });

      xhr.addEventListener('error', () => {
        message.error('Error uploading headshot');
        onError?.(new Error('Network error'));
      });

      xhr.open('POST', '/api/admin/headshot/upload');
      xhr.send(formData);
    } catch (error) {
      console.error('Error uploading headshot:', error);
      message.error('Error uploading headshot');
      onError?.(error as Error);
    }
  };

  // Track files that need to be uploaded (batched)
  const pendingUploadRef = useRef<Array<{ file: File; fileName: string; onSuccess?: (response?: any) => void; onError?: (error: any) => void; onProgress?: (event: { percent: number }) => void }>>([]);
  const isUploadingRef = useRef(false);
  const uploadTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleGalleryImageUpload: UploadProps['customRequest'] = async ({ file, onSuccess, onError, onProgress }) => {
    if (!initialData?.id) {
      message.warning('Please save the entry first before uploading gallery images.');
      onError?.(new Error('Entry not saved'));
      return;
    }

    const fileName = (file as File).name;
    
    // Add file to pending queue
    pendingUploadRef.current.push({ file: file as File, fileName, onSuccess, onError, onProgress });

    // Debug: Track upload start
    if (isDebugMode) {
      setDebugInfo(prev => ({
        ...prev,
        uploadQueue: [...prev.uploadQueue, { filename: fileName, status: 'pending' }],
      }));
    }

    // Clear any existing timeout
    if (uploadTimeoutRef.current) {
      clearTimeout(uploadTimeoutRef.current);
    }

    // Wait a short time (100ms) to batch multiple files together (if user selects multiple at once)
    uploadTimeoutRef.current = setTimeout(async () => {
      // Check if already uploading or queue is empty
      if (isUploadingRef.current || pendingUploadRef.current.length === 0) {
        return;
      }

      isUploadingRef.current = true;
      const filesToUpload = [...pendingUploadRef.current];
      pendingUploadRef.current = [];
      uploadTimeoutRef.current = null;

      const formData = new FormData();
      filesToUpload.forEach(({ file }) => {
        formData.append('images', file);
      });
      formData.append('actressId', initialData.id.toString());
      formData.append('type', 'gallery');
      if (isDebugMode) {
        formData.append('debug', '1');
      }

      // Update all files to uploading status
      if (isDebugMode) {
        setDebugInfo(prev => ({
          ...prev,
          uploadQueue: prev.uploadQueue.map(f => 
            filesToUpload.some(u => u.fileName === f.filename) ? { ...f, status: 'uploading' } : f
          ),
        }));
      }

      try {
        const xhr = new XMLHttpRequest();

        // Track upload progress for all files (show combined progress)
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percent = Math.round((e.loaded / e.total) * 100);
            // Report progress to all file handlers
            filesToUpload.forEach(({ onProgress }) => {
              onProgress?.({ percent });
            });
          }
        });

        xhr.addEventListener('load', async () => {
        let parsed: any = null;
        try {
          parsed = xhr.responseText ? JSON.parse(xhr.responseText) : null;
        } catch {
          parsed = null;
        }

          // Debug: Track API response
          if (isDebugMode) {
            const uploadedImages = parsed?.images || [];
            setDebugInfo(prev => ({
              ...prev,
              apiResponses: [...prev.apiResponses, {
                endpoint: '/api/admin/images/upload',
                method: 'POST',
                status: xhr.status,
                timestamp: Date.now(),
                response: parsed,
                rowsInserted: uploadedImages.length,
                error: xhr.status !== 200 ? (parsed?.error || parsed?.details || 'Unknown error') : undefined,
              }],
              uploadQueue: prev.uploadQueue.map(f => {
                const uploaded = uploadedImages.find((img: any, idx: number) => filesToUpload[idx]?.fileName === f.filename);
                if (uploaded) {
                  return {
                    ...f,
                    status: 'success',
                    imageId: uploaded.id,
                    orderNum: uploaded.orderNum,
                  };
                } else if (xhr.status !== 200) {
                  return {
                    ...f,
                    status: 'failed',
                    error: parsed?.error || parsed?.details || 'Upload failed',
                  };
                }
                return f;
              }),
            }));
          }

          if (xhr.status === 200) {
            const data = parsed;
            message.success(`Gallery images uploaded successfully! ${data.images?.length || filesToUpload.length} image(s) processed.`);
            
            // Call onSuccess for all files
            filesToUpload.forEach(({ onSuccess }) => {
              onSuccess?.(data);
            });
            
            // Invalidate cache to refresh image counts in listing
            if (typeof window !== 'undefined') {
              window.dispatchEvent(new Event('admin-girls-cache-invalidate'));
            }
            
            // Fetch updated images from the API instead of reloading the page
            if (initialData?.id) {
              try {
                const response = await fetch(`/api/admin/girls/${initialData.id}`);
                if (response.ok) {
                  const updatedGirl = await response.json();
                  // Update images in formData
                  handleChange('images', updatedGirl.images || []);
                  // Keep the gallery tab active
                  setActiveTab('gallery');
                }
              } catch (error) {
                console.error('Error fetching updated images:', error);
                // Fallback: still update the tab even if fetch fails
                setActiveTab('gallery');
              }
            }
          } else {
            const details = String(parsed?.details || parsed?.message || '').trim();
            const errMsgRaw = String(parsed?.error || 'Upload failed').trim();

            // Avoid duplicated "Failed to upload images: Failed to upload images"
            const errMsg =
              details ||
              (errMsgRaw.toLowerCase().startsWith('failed to upload images')
                ? 'Upload failed (server did not provide details)'
                : errMsgRaw);

            message.error(`Failed to upload images: ${errMsg}`);
            // Call onError for all files
            filesToUpload.forEach(({ onError }) => {
              if (onError) onError(new Error(errMsg));
            });
          }

          // Reset upload flag
          isUploadingRef.current = false;
        });

        xhr.addEventListener('error', () => {
          // Debug: Track error
          if (isDebugMode) {
            setDebugInfo(prev => ({
              ...prev,
              uploadQueue: prev.uploadQueue.map(f => 
                filesToUpload.some(u => u.fileName === f.filename) ? { ...f, status: 'failed', error: 'Network error' } : f
              ),
            }));
          }
          message.error('Error uploading gallery images');
          // Call onError for all files
          filesToUpload.forEach(({ onError }) => {
            if (onError) onError(new Error('Network error'));
          });
          // Reset upload flag
          isUploadingRef.current = false;
        });

        xhr.open('POST', '/api/admin/images/upload');
        xhr.send(formData);
      } catch (error) {
        // Debug: Track error
        if (isDebugMode) {
          setDebugInfo(prev => ({
            ...prev,
            uploadQueue: prev.uploadQueue.map(f => 
              filesToUpload.some(u => u.fileName === f.filename) ? { ...f, status: 'failed', error: String(error) } : f
            ),
          }));
        }
        console.error('Error uploading gallery images:', error);
        message.error('Error uploading gallery images');
        // Call onError for all files
        filesToUpload.forEach(({ onError }) => {
          if (onError) onError(error as Error);
        });
        // Reset upload flag
        isUploadingRef.current = false;
      }
    }, 100); // 100ms batching delay
  };

  const tabItems = [
    {
      key: 'general',
      label: 'General Info',
      children: (
        <div className="space-y-3" style={{ paddingTop: '8px' }}>
          {/* Headshot Upload - Horizontal Layout */}
          <div>
            <Title level={4} style={{ marginBottom: '8px', fontSize: '14px' }}>Headshot (Portrait Photo)</Title>
            <div className="flex items-start gap-3">
              {initialData?.headshotUrl && (
                <div className="relative flex-shrink-0">
                  <div className="relative bg-gray-100 border border-gray-300 rounded overflow-hidden" style={{ width: 'auto', height: '200px', aspectRatio: '190/245' }}>
                    <img 
                      src={initialData.headshotUrl} 
                      alt="Headshot" 
                      className="h-full w-auto object-cover"
                      style={{ height: '200px', width: 'auto' }}
                      loading="lazy"
                      onError={(e) => {
                        (e.target as HTMLImageElement).style.display = 'none';
                      }}
                    />
                  </div>
                </div>
              )}
              <div className="flex flex-col gap-2 flex-1">
                <Upload
                  accept="image/*"
                  customRequest={handleHeadshotUpload}
                  fileList={headshotFileList}
                  onChange={({ fileList }) => {
                    setHeadshotFileList(fileList);
                    // Clear file list after successful upload
                    if (fileList[0]?.status === 'done') {
                      setTimeout(() => {
                        setHeadshotFileList([]);
                      }, 2000);
                    }
                  }}
                  maxCount={1}
                  showUploadList={{
                    showPreviewIcon: false,
                    showRemoveIcon: false,
                  }}
                >
                  <Button icon={<UploadOutlined />} size="small">
                    {initialData?.headshotUrl ? 'Replace Headshot' : 'Upload Headshot'}
                  </Button>
                </Upload>
                <p className="text-xs text-gray-500" style={{ fontSize: '11px', lineHeight: '1.4', margin: 0 }}>
                  Image will be automatically cropped<br />
                  and resized to 190px Ã— 245px.
                </p>
              </div>
            </div>
          </div>

          {/* Basic Information - Compact 2 Column Layout */}
          <div>
            <Title level={4} style={{ marginBottom: '8px', fontSize: '14px' }}>Basic Information</Title>
            <Row gutter={[12, 12]}>
              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text strong style={{ fontSize: '12px' }}>Name *</Text>
                </div>
                <Form.Item
                  validateStatus={errors.name ? 'error' : ''}
                  help={errors.name}
                  style={{ marginBottom: '12px' }}
                >
                  <Input
                    value={formData.name}
                    onChange={(e) => handleChange('name', e.target.value)}
                    required
                    size="small"
                    style={{ maxWidth: '100%' }}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text strong style={{ fontSize: '12px' }}>Slug *</Text>
                </div>
                <Form.Item
                  validateStatus={errors.slug ? 'error' : ''}
                  help={errors.slug}
                  style={{ marginBottom: '12px' }}
                >
                  <Input
                    value={formData.slug}
                    onChange={(e) => handleChange('slug', e.target.value)}
                    required
                    size="small"
                    style={{ maxWidth: '100%' }}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text style={{ fontSize: '12px' }}>First Name</Text>
                </div>
                <Form.Item style={{ marginBottom: '12px' }}>
                  <Input
                    value={formData.firstName}
                    onChange={(e) => handleChange('firstName', e.target.value)}
                    size="small"
                    style={{ maxWidth: '100%' }}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text style={{ fontSize: '12px' }}>Last Name</Text>
                </div>
                <Form.Item style={{ marginBottom: '12px' }}>
                  <Input
                    value={formData.lastName}
                    onChange={(e) => handleChange('lastName', e.target.value)}
                    size="small"
                    style={{ maxWidth: '100%' }}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text style={{ fontSize: '12px' }}>Middle Names</Text>
                </div>
                <Form.Item style={{ marginBottom: '12px' }}>
                  <Input
                    value={formData.middleNames}
                    onChange={(e) => handleChange('middleNames', e.target.value)}
                    size="small"
                    style={{ maxWidth: '100%' }}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} sm={12}>
                <div style={{ marginBottom: '4px' }}>
                  <Text strong style={{ fontSize: '12px' }}>Era/Decade *</Text>
                </div>
                <Form.Item style={{ marginBottom: '12px' }}>
                  <Select
                    value={formData.theirMan ? 'men' : formData.era}
                    onChange={(value) => {
                      if (value === 'men') {
                        setFormData(prev => ({ ...prev, theirMan: true, era: 3 }));
                      } else {
                        setFormData(prev => ({ ...prev, theirMan: false, era: parseInt(value) }));
                      }
                    }}
                    size="small"
                    style={{ width: '100%' }}
                  >
                    <Option value={1}>1920s-1930s</Option>
                    <Option value={2}>1940s</Option>
                    <Option value={3}>1950s</Option>
                    <Option value={4}>1960s</Option>
                    <Option value="men">Their Men</Option>
                  </Select>
                </Form.Item>
              </Col>
            </Row>

            {/* Status Checkboxes - Compact */}
            <Row gutter={[12, 8]} style={{ marginTop: '12px' }}>
              <Col>
                <Checkbox
                  checked={formData.isNew}
                  onChange={(e) => handleChange('isNew', e.target.checked)}
                  style={{ fontSize: '12px' }}
                >
                  <Text style={{ fontSize: '12px' }}>Is New</Text>
                </Checkbox>
              </Col>

              <Col>
                <Checkbox
                  checked={formData.hasNewPhotos}
                  onChange={(e) => handleChange('hasNewPhotos', e.target.checked)}
                  style={{ fontSize: '12px' }}
                >
                  <Text style={{ fontSize: '12px' }}>Has New Photos</Text>
                </Checkbox>
              </Col>

              <Col>
                <Checkbox
                  checked={formData.published}
                  onChange={(e) => handleChange('published', e.target.checked)}
                  style={{ fontSize: '12px' }}
                >
                  <Text style={{ fontSize: '12px' }}>Published</Text>
                </Checkbox>
              </Col>
            </Row>
          </div>
        </div>
      ),
    },
    {
      key: 'timeline',
      label: 'Timeline Events',
      children: (
        <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
          {(() => {
            // Debug: Log current timeline state
            console.log(`[GirlForm Render] formData.timeline.length: ${formData.timeline.length}`);
            
            // Ensure all events have ord values, then sort by ord for display
            const timelineWithOrd = formData.timeline.map((event, idx) => ({
              ...event,
              ord: event.ord || (idx + 1),
            }));
            
            // Sort timeline by ord for display
            const sortedTimeline = [...timelineWithOrd].sort((a, b) => {
              const ordA = a.ord || 0;
              const ordB = b.ord || 0;
              return ordA - ordB;
            });
            
            console.log(`[GirlForm Render] sortedTimeline.length: ${sortedTimeline.length}`);
            
            // Use unique key: database id if available, otherwise _originalIndex, otherwise fallback
            return sortedTimeline.map((event: any, displayIndex: number) => {
              // Use _originalIndex if available, otherwise find by matching
              let eventIndex = event._originalIndex;
              
              if (eventIndex === undefined || eventIndex < 0) {
                // Fallback: try to find by matching content
                eventIndex = formData.timeline.findIndex((e: any, idx: number) => {
                  // Try exact match first
                  if (e === event) return true;
                  // Then try matching by content
                  return String(e.date || '') === String(event.date || '') && 
                         String(e.event || '') === String(event.event || '');
                });
                
                // Last resort: use displayIndex
                if (eventIndex < 0) {
                  console.warn(`Could not find original index for event at display position ${displayIndex}, using displayIndex`);
                  eventIndex = displayIndex;
                }
              }
              
              // Generate unique key: prefer database id, fallback to _originalIndex, then eventIndex
              // This ensures React keys are always unique
              const uniqueKey = event.id 
                ? `timeline-${event.id}` 
                : event._originalIndex !== undefined 
                  ? `timeline-unsaved-${event._originalIndex}` 
                  : `timeline-fallback-${eventIndex}`;
              
              const totalEvents = formData.timeline.length;
              
              return (
                <Card key={uniqueKey} size="small">
                  <Row gutter={[16, 12]}>
                    {/* Column 1: Order number, Date, Order dropdown */}
                    <Col xs={24} sm={8} md={4}>
                      <div className="space-y-3">
                        <div>
                          <Text type="secondary" style={{ fontSize: '12px' }}>#{event.ord || eventIndex + 1}</Text>
                        </div>
                        <div>
                          <Text style={{ fontSize: '12px', display: 'block', marginBottom: '4px' }}>Date:</Text>
                          <Input
                            value={event.date || ''}
                            onChange={(e) => {
                              const newTimeline = [...formData.timeline];
                              if (newTimeline[eventIndex]) {
                                newTimeline[eventIndex] = { 
                                  ...newTimeline[eventIndex], 
                                  date: e.target.value,
                                  _originalIndex: newTimeline[eventIndex]._originalIndex !== undefined 
                                    ? newTimeline[eventIndex]._originalIndex 
                                    : eventIndex,
                                };
                                handleChange('timeline', newTimeline);
                              }
                            }}
                            placeholder="e.g., 15 May 36"
                            size="small"
                          />
                        </div>
                        <div>
                          <Text style={{ fontSize: '12px', display: 'block', marginBottom: '4px' }}>Order:</Text>
                          <Select
                            value={event.ord || displayIndex + 1}
                            onChange={(value) => handleTimelineOrderChange(displayIndex, value)}
                            size="small"
                            style={{ width: '100%' }}
                          >
                            {Array.from({ length: totalEvents }, (_, i) => i + 1).map((orderNum) => (
                              <Option key={orderNum} value={orderNum}>
                                {orderNum}
                              </Option>
                            ))}
                          </Select>
                        </div>
                      </div>
                    </Col>
                    {/* Column 2: Event label, text area, delete button */}
                    <Col xs={24} sm={16} md={18}>
                      <div className="flex flex-col gap-2">
                        <div>
                          <Text style={{ fontSize: '12px', fontWeight: 500 }}>Event:</Text>
                        </div>
                        <Form.Item style={{ marginBottom: 0 }}>
                          <SimpleEditor
                            value={event.event || ''}
                            onChange={(value) => {
                              const newTimeline = [...formData.timeline];
                              if (newTimeline[eventIndex]) {
                                newTimeline[eventIndex] = { 
                                  ...newTimeline[eventIndex], 
                                  event: value,
                                  _originalIndex: newTimeline[eventIndex]._originalIndex !== undefined 
                                    ? newTimeline[eventIndex]._originalIndex 
                                    : eventIndex,
                                };
                                handleChange('timeline', newTimeline);
                              }
                            }}
                            placeholder="Event description"
                            rows={3}
                          />
                        </Form.Item>
                        <div className="flex justify-end" style={{ marginTop: '4px' }}>
                          <Button
                            type="default"
                            danger
                            size="small"
                            icon={<DeleteOutlined />}
                            onClick={() => {
                              modal.confirm({
                                title: 'Delete Timeline Event',
                                content: 'Are you sure you want to delete this timeline event?',
                                okText: 'Delete',
                                okType: 'danger',
                                onOk: async () => {
                                  // CRITICAL: Delete by database ID only
                                  // Find the event to get its ID
                                  const eventToDelete = formData.timeline.find((e: any) => {
                                    // Match by id (primary key)
                                    if (event.id && e.id && Number(e.id) === Number(event.id)) {
                                      return true;
                                    }
                                    // Match by _originalIndex as fallback (for new unsaved events)
                                    if (event._originalIndex !== undefined && e._originalIndex === event._originalIndex) {
                                      return true;
                                    }
                                    return false;
                                  });
                                  
                                  if (!eventToDelete) {
                                    console.error('[Delete] Could not find event to delete:', event);
                                    message.error('Could not find event to delete');
                                    return;
                                  }
                                  
                                  // If event has no ID, it's a new unsaved event - just remove from state
                                  if (!eventToDelete.id || eventToDelete.id === null || eventToDelete.id === undefined) {
                                    console.log('[Delete] Deleting unsaved event (no ID)');
                                    const newTimeline = formData.timeline.filter((e: any) => {
                                      if (e._originalIndex !== undefined && eventToDelete._originalIndex !== undefined) {
                                        return e._originalIndex !== eventToDelete._originalIndex;
                                      }
                                      return e !== eventToDelete;
                                    });
                                    const normalized = normalizeTimelineOrders(newTimeline);
                                    const normalizedWithIds = normalized.map((e: any, idx: number) => ({
                                      ...e,
                                      _originalIndex: e._originalIndex !== undefined ? e._originalIndex : idx,
                                    }));
                                    handleChange('timeline', normalizedWithIds);
                                    message.success('Event deleted');
                                    return;
                                  }
                                  
                                  // Delete via API endpoint using database ID
                                  const eventId = Number(eventToDelete.id);
                                  const girlId = initialData?.id;
                                  
                                  if (!girlId) {
                                    message.error('Cannot delete: Girl ID not found');
                                    return;
                                  }
                                  
                                  try {
                                    console.log(`[Delete] Calling DELETE endpoint for event ID ${eventId} of girl ${girlId}`);
                                    
                                    const response = await fetch(
                                      `/api/admin/girls/${girlId}/timeline/${eventId}`,
                                      {
                                        method: 'DELETE',
                                        headers: { 'Content-Type': 'application/json' },
                                      }
                                    );
                                    
                                    const data = await response.json();
                                    
                                    if (!response.ok) {
                                      console.error('[Delete] API error:', data);
                                      message.error(data.error || 'Failed to delete timeline event');
                                      return;
                                    }
                                    
                                    // Remove from state after successful deletion
                                    const newTimeline = formData.timeline.filter((e: any) => {
                                      if (e.id && Number(e.id) === eventId) {
                                        return false; // Exclude deleted event
                                      }
                                      return true;
                                    });
                                    
                                    // Re-normalize orders after deletion
                                    const normalized = normalizeTimelineOrders(newTimeline);
                                    const normalizedWithIds = normalized.map((e: any, idx: number) => ({
                                      ...e,
                                      _originalIndex: e._originalIndex !== undefined ? e._originalIndex : idx,
                                    }));
                                    
                                    handleChange('timeline', normalizedWithIds);
                                    message.success('Timeline event deleted successfully');
                                    
                                    console.log(`[Delete] Successfully deleted event ID ${eventId}, timeline count: ${formData.timeline.length} -> ${newTimeline.length}`);
                                    
                                  } catch (error: any) {
                                    console.error('[Delete] Error:', error);
                                    message.error('Failed to delete timeline event: ' + (error.message || 'Unknown error'));
                                  }
                                },
                              });
                            }}
                          >
                            Delete
                          </Button>
                        </div>
                      </div>
                    </Col>
                  </Row>
                </Card>
              );
            });
          })()}
          <Button
            type="default"
            icon={<PlusOutlined />}
            onClick={() => {
              const maxOrd = formData.timeline.length > 0
                ? Math.max(...formData.timeline.map((e: any) => e.ord || 0))
                : 0;
              const newIndex = formData.timeline.length;
              handleChange('timeline', [
                ...formData.timeline, 
                { 
                  date: '', 
                  event: '', 
                  ord: maxOrd + 1,
                  _originalIndex: newIndex,
                }
              ]);
            }}
            style={{ marginTop: '8px' }}
          >
            Add Event
          </Button>
        </Space>
      ),
    },
    {
      key: 'sources',
      label: 'Sources/Links',
      children: (
        <div className="space-y-6">
          {/* Sources */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Sources</Title>
            <p className="text-xs text-gray-600 mb-1.5" style={{ fontSize: '11px' }}>
              Use the Bold (B) and Italic (I) buttons to format text. The preview shows how it will appear.
            </p>
            <SimpleEditor
              value={formData.sources}
              onChange={(value) => handleChange('sources', value)}
              placeholder="Enter sources here..."
              rows={4}
            />
          </div>

          {/* Links */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Links</Title>
            <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
              {formData.links.map((link: any, index: number) => (
                <Card key={link.id || index} size="small">
                  <Row gutter={[16, 16]} align="middle">
                    <Col span={2}>
                      <Text type="secondary">#{index + 1}</Text>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>Link Text:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          value={link.text || ''}
                          onChange={(e) => {
                            const newLinks = [...formData.links];
                            newLinks[index] = { ...link, text: e.target.value };
                            handleChange('links', newLinks);
                          }}
                          placeholder="e.g., Filmography"
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>URL:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          type="url"
                          value={link.url || ''}
                          onChange={(e) => {
                            const newLinks = [...formData.links];
                            newLinks[index] = { ...link, url: e.target.value };
                            handleChange('links', newLinks);
                          }}
                          placeholder="https://..."
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={2}>
                      <Button
                        type="default"
                        danger
                        size="small"
                        icon={<DeleteOutlined />}
                        onClick={() => {
                          modal.confirm({
                            title: 'Delete Link',
                            content: 'Are you sure you want to delete this link?',
                            okText: 'Delete',
                            okType: 'danger',
                            onOk: () => {
                              const newLinks = formData.links.filter((_: any, i: number) => i !== index);
                              handleChange('links', newLinks);
                            },
                          });
                        }}
                      >
                        Delete
                      </Button>
                    </Col>
                  </Row>
                </Card>
              ))}
              <Button
                type="default"
                icon={<PlusOutlined />}
                onClick={() => {
                  handleChange('links', [...formData.links, { text: '', url: '', ord: formData.links.length + 1 }]);
                }}
              >
                Add Link
              </Button>
            </Space>
          </div>

          {/* Recommended Books */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Recommended Books</Title>
            <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
              {formData.books.map((book: any, index: number) => (
                <Card key={book.id || index} size="small">
                  <Row gutter={[16, 16]} align="middle">
                    <Col span={2}>
                      <Text type="secondary">#{index + 1}</Text>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>Book Title:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          value={book.title || ''}
                          onChange={(e) => {
                            const newBooks = [...formData.books];
                            newBooks[index] = { ...book, title: e.target.value };
                            handleChange('books', newBooks);
                          }}
                          placeholder="e.g., Western Women by Boyd Magers"
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>URL:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          type="url"
                          value={book.url || ''}
                          onChange={(e) => {
                            const newBooks = [...formData.books];
                            newBooks[index] = { ...book, url: e.target.value };
                            handleChange('books', newBooks);
                          }}
                          placeholder="https://..."
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={2}>
                      <Button
                        type="default"
                        danger
                        size="small"
                        icon={<DeleteOutlined />}
                        onClick={() => {
                          modal.confirm({
                            title: 'Delete Book',
                            content: 'Are you sure you want to delete this book?',
                            okText: 'Delete',
                            okType: 'danger',
                            onOk: () => {
                              const newBooks = formData.books.filter((_: any, i: number) => i !== index);
                              handleChange('books', newBooks);
                            },
                          });
                        }}
                      >
                        Delete
                      </Button>
                    </Col>
                  </Row>
                </Card>
              ))}
              <Button
                type="default"
                icon={<PlusOutlined />}
                onClick={() => {
                  handleChange('books', [...formData.books, { title: '', url: '', ord: formData.books.length + 1 }]);
                }}
              >
                Add Book
              </Button>
            </Space>
          </div>
        </div>
      ),
    },
    {
      key: 'seo',
      label: 'SEO & Meta Tags',
      children: (
        <div>
          {initialData?.id && (
            <SEOFormSectionEnhanced
              actressId={initialData.id}
              actressData={{
                name: formData.name,
                firstName: formData.firstName,
                lastName: formData.lastName,
                era: formData.era,
                slug: formData.slug,
                galleryCount: formData.images?.length || 0,
              }}
              initialSEO={formData.seo}
            />
          )}
          {!initialData?.id && (
            <p className="text-xs text-gray-500" style={{ fontSize: '11px' }}>
              Please save the entry first before managing SEO data.
            </p>
          )}
        </div>
      ),
    },
    {
      key: 'gallery',
      label: 'Gallery Images',
      children: (
        <div>
          {/* Debug Panel */}
          {isDebugMode && (
                <ImageDebugPanel
                  images={formData.images || []}
                  uploadQueue={debugInfo.uploadQueue}
                  apiResponses={debugInfo.apiResponses}
                  isVisible={isDebugMode}
                  girlId={initialData?.id}
                  onReloadFromDb={async () => {
                    // Reload images from API after DB truth check
                    if (initialData?.id) {
                      try {
                        const fetchRes = await fetch(`/api/admin/girls/${initialData.id}`);
                        if (fetchRes.ok) {
                          const updatedGirl = await fetchRes.json();
                          handleChange('images', updatedGirl.images || []);
                        }
                      } catch (error) {
                        console.error('[GirlForm] Error reloading images:', error);
                      }
                    }
                  }}
                />
          )}
          
          <div className="flex items-center justify-between mb-4">
            {initialData?.id && (
              <Upload
                accept="image/*"
                multiple
                customRequest={handleGalleryImageUpload}
                fileList={galleryFileList}
                onChange={({ fileList }) => {
                  setGalleryFileList(fileList);
                  // Clear file list after successful upload
                  const allDone = fileList.every(file => file.status === 'done' || file.status === 'error');
                  if (allDone && fileList.length > 0) {
                    setTimeout(() => {
                      setGalleryFileList([]);
                    }, 2000);
                  }
                }}
                showUploadList={{
                  showPreviewIcon: false,
                  showRemoveIcon: true,
                }}
              >
                <Button icon={<UploadOutlined />} type="default">
                  Upload Gallery Images
                </Button>
              </Upload>
            )}
          </div>
          {!initialData?.id && (
            <p className="text-xs text-gray-500 mb-3" style={{ fontSize: '11px' }}>Please save the entry first before uploading gallery images.</p>
          )}
          {formData.images && formData.images.length > 0 ? (
            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm text-gray-600">
                  {formData.images.length} image{formData.images.length !== 1 ? 's' : ''} found
                </div>
                <Text style={{ fontSize: '12px', color: '#666' }}>
                  Order saves on <Text strong>Save</Text> / <Text strong>Save &amp; Back</Text>
                </Text>
              </div>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {[...formData.images]
                  .sort((a: any, b: any) => {
                    const orderA = a.orderNum ?? 999999;
                    const orderB = b.orderNum ?? 999999;
                    if (orderA !== orderB) return orderA - orderB;
                    return a.id - b.id;
                  })
                  .map((img: any, displayIndex: number) => {
                  // Use the database path (img.path) for thumbnail API, not the Supabase URL
                  const galleryPath = img.path || '';
                  
                  // Use larger, higher quality thumbnails for admin (500x600px for better quality)
                  let thumbnailUrl = '';
                  let fullImageUrl = '';
                  if (galleryPath) {
                    thumbnailUrl = `/api/images/thumbnail?path=${encodeURIComponent(galleryPath)}&width=500&height=600`;
                    fullImageUrl = `/api/images/thumbnail?path=${encodeURIComponent(galleryPath)}&width=1200&height=1600`;
                  }
                  
                  // SERVER-AUTHORITATIVE: Frontend only updates visual order in local state
                  // Actual order_num is assigned by server when the main form is saved
                  // CRITICAL: Must create new objects to trigger React re-render
                  const updateImageOrder = (imageId: number, newOrder: number) => {
                    setFormData((prev: any) => {
                      // First, sort by current orderNum to get stable base order
                      const sortedImages = [...(prev.images || [])].sort((a: any, b: any) => {
                        const orderA = a.orderNum ?? 999999;
                        const orderB = b.orderNum ?? 999999;
                        if (orderA !== orderB) return orderA - orderB;
                        return a.id - b.id;
                      });
                      
                      const imageIndex = sortedImages.findIndex((i: any) => i.id === imageId);
                      if (imageIndex === -1) return prev;
                      
                      // Move image to new position (visual reorder only)
                      const [movedImage] = sortedImages.splice(imageIndex, 1);
                      sortedImages.splice(newOrder - 1, 0, movedImage);
                      
                      // Create NEW objects with updated orderNum (don't mutate)
                      const reorderedImages = sortedImages.map((img: any, idx: number) => ({
                        ...img,
                        orderNum: idx + 1, // Update orderNum for display (temporary, server will reassign on save)
                      }));
                      
                      return { ...prev, images: reorderedImages };
                    });
                  };
                  
                  const handleDeleteImage = async () => {
                    modal.confirm({
                      title: 'Delete Image',
                      content: 'Are you sure you want to delete this image? This action cannot be undone.',
                      onOk: async () => {
                        try {
                          const url = isDebugMode ? `/api/admin/images/${img.id}?debug=1` : `/api/admin/images/${img.id}`;
                          const res = await fetch(url, {
                            method: 'DELETE',
                          });
                          
                          const responseData = await res.json();
                          
                          // Debug: Track API response
                          if (isDebugMode) {
                            setDebugInfo(prev => ({
                              ...prev,
                              apiResponses: [...prev.apiResponses, {
                                endpoint: `/api/admin/images/${img.id}`,
                                method: 'DELETE',
                                status: res.status,
                                timestamp: Date.now(),
                                payload: { id: img.id },
                                response: responseData,
                                rowsDeleted: responseData.deleted ? 1 : 0,
                                error: res.ok ? undefined : (responseData.error || 'Unknown error'),
                              }],
                            }));
                          }

                          if (res.ok) {
                            // Optimistic UI update: remove and re-pack orderNum to avoid gappy state (e.g. 1,2,4)
                            // Backend also renormalizes order_num, but we must keep UI state consistent immediately.
                            const remaining = (formData.images || []).filter((i: any) => i.id !== img.id);
                            const normalized = [...remaining]
                              .sort((a: any, b: any) => {
                                const orderA = a.orderNum ?? 999999;
                                const orderB = b.orderNum ?? 999999;
                                if (orderA !== orderB) return orderA - orderB;
                                return a.id - b.id;
                              })
                              .map((i: any, idx: number) => ({
                                ...i,
                                orderNum: idx + 1,
                              }));
                            handleChange('images', normalized);
                            message.success('Image deleted successfully');

                            // Server-authoritative refresh: re-fetch to ensure we match DB truth (and any backend adjustments)
                            if (initialData?.id) {
                              try {
                                const fetchRes = await fetch(`/api/admin/girls/${initialData.id}`);
                                if (fetchRes.ok) {
                                  const updatedGirl = await fetchRes.json();
                                  handleChange('images', updatedGirl.images || []);
                                } else {
                                  console.error('[GirlForm] Failed to refresh images after delete:', fetchRes.status);
                                  message.warning('Deleted, but failed to refresh from server. Please reload the page.');
                                }
                              } catch (fetchError) {
                                console.error('[GirlForm] Error refreshing images after delete:', fetchError);
                                message.warning('Deleted, but failed to refresh from server. Please reload the page.');
                              }
                            }
                            
                            // Invalidate cache to refresh image counts in listing
                            if (typeof window !== 'undefined') {
                              window.dispatchEvent(new Event('admin-girls-cache-invalidate'));
                            }
                          } else {
                            message.error(`Failed to delete image: ${responseData.error || 'Unknown error'}`);
                          }
                        } catch (error) {
                          console.error('Error deleting image:', error);
                          message.error('Error deleting image');
                        }
                      },
                    });
                  };
                  
                  return (
                    <div key={img.id || displayIndex} className="border border-gray-300 p-1.5 bg-white relative">
                      <div className="relative" style={{ aspectRatio: '4/5', minHeight: '200px' }}>
                        {thumbnailUrl ? (
                          <img 
                            src={thumbnailUrl} 
                            alt={`Image ${img.orderNum || displayIndex + 1}`}
                            className="w-full h-full object-cover bg-gray-100 cursor-pointer hover:opacity-90 transition-opacity"
                            loading="lazy"
                            style={{ minHeight: '200px' }}
                            onClick={() => {
                              if (fullImageUrl) {
                                window.open(fullImageUrl, '_blank');
                              }
                            }}
                            title="Click to view full size"
                            onError={(e) => {
                              const target = e.target as HTMLImageElement;
                              target.style.display = 'none';
                              const parent = target.parentElement;
                              if (parent) {
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'w-full h-full bg-gray-200 flex items-center justify-center text-xs text-gray-500';
                                errorDiv.textContent = 'Failed to load';
                                parent.appendChild(errorDiv);
                              }
                            }}
                          />
                        ) : (
                          <div className="w-full h-full bg-gray-200 flex items-center justify-center text-xs text-gray-500" style={{ minHeight: '200px' }}>
                            No image
                          </div>
                        )}
                        <Button
                          size="small"
                          danger
                          onClick={(e) => {
                            e.stopPropagation(); // Prevent triggering image click
                            handleDeleteImage();
                          }}
                          style={{ 
                            position: 'absolute', 
                            top: '4px', 
                            right: '4px', 
                            zIndex: 10,
                            minWidth: '24px',
                            width: '24px',
                            height: '24px',
                            padding: 0,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                          }}
                          title="Delete image"
                        >
                          Ã—
                        </Button>
                      </div>
                      <div className="mt-1.5 text-xs text-gray-600 space-y-1" style={{ fontSize: '10px' }}>
                        {/* Order Control */}
                        <div className="flex items-center gap-2">
                          <Text style={{ fontSize: '10px' }}>Order:</Text>
                          <Select
                            value={img.orderNum || displayIndex + 1}
                            onChange={(value) => {
                              const newOrder = parseInt(String(value)) || 1;
                              updateImageOrder(img.id, newOrder);
                            }}
                            size="small"
                            style={{ width: '60px', fontSize: '10px' }}
                          >
                            {Array.from({ length: formData.images?.length || 1 }, (_, i) => i + 1).map((order) => (
                              <Option key={order} value={order}>
                                {order}
                              </Option>
                            ))}
                          </Select>
                        </div>
                        <div>
                          Gallery: {img.width && img.height ? `${img.width} Ã— ${img.height} px` : 'Unknown size'}
                        </div>
                        {img.hq && (
                          <div className="text-green-600 font-semibold">
                            âœ“ HQ Available: {img.hq.width} Ã— {img.hq.height} px
                            {img.hq.sizeMB !== null && img.hq.sizeMB !== undefined 
                              ? ` (${img.hq.sizeMB} MB)` 
                              : ' (â€”)'}
                          </div>
                        )}
                        {img.originalWidth && img.originalHeight && (
                          <div className="text-gray-700 font-medium">
                            Original: {img.originalWidth} Ã— {img.originalHeight} px
                            {img.originalFileBytes && ` (${(img.originalFileBytes / (1024 * 1024)).toFixed(1)} MB)`}
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="text-sm text-gray-500 py-4">
              No gallery images found. Upload images using the uploader above.
            </div>
          )}
        </div>
      ),
    },
  ];

  return (
    <Card>
      <div style={{ marginBottom: 12 }}>
        {initialData?.id ? (
          <Button
            type="link"
            style={{ padding: 0, height: 'auto', fontSize: 12 }}
            onClick={(evt) => {
              evt.preventDefault();
              saveModeRef.current = 'back';
              if (formRef.current) formRef.current.requestSubmit();
              else router.push(backHref);
            }}
          >
            â† Back to list
          </Button>
        ) : (
          <Button
            type="link"
            style={{ padding: 0, height: 'auto', fontSize: 12 }}
            onClick={() => router.push(backHref)}
          >
            â† Back to list
          </Button>
        )}
      </div>
      <form ref={formRef} onSubmit={handleSubmit}>
      <Tabs
        activeKey={activeTab}
        onChange={setActiveTab}
        items={tabItems}
        type="card"
        size="small"
        style={{
          fontSize: '13px',
        }}
        className="compact-tabs responsive-tabs"
        tabBarStyle={{
          marginBottom: 0,
        }}
      />

      {/* Error Message */}
      {errors.submit && (
        <Alert
          title={errors.submit}
          type="error"
          showIcon
          closable
          onClose={() => setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors.submit;
            return newErrors;
          })}
        />
      )}

      {/* Submit Buttons */}
      <Space style={{ marginTop: '24px' }}>
        <Button
          htmlType="submit"
          loading={isSubmitting}
          size="large"
          onClick={() => {
            saveModeRef.current = 'stay';
          }}
          style={{ 
            fontWeight: 'bold',
            borderWidth: '2px',
            borderStyle: 'solid',
            borderColor: '#000000',
            backgroundColor: '#f5f5f5',
            color: '#000000'
          }}
        >
          {isSubmitting ? 'Saving...' : 'Save'}
        </Button>

        {initialData?.id && (
          <Button
            htmlType="submit"
            loading={isSubmitting}
            size="large"
            onClick={() => {
              saveModeRef.current = 'back';
            }}
            type="primary"
          >
            Save & Back
          </Button>
        )}
      </Space>
      </form>
    </Card>
  );
}

