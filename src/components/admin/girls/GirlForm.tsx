'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { generateSlug } from '@/lib/validations/girl';
import SimpleEditor from '@/components/admin/SimpleEditor';
import SEOFormSectionEnhanced from '@/components/admin/girls/SEOFormSectionEnhanced';
import type { SEOData } from '@/lib/seo/generate-seo-enhanced';
import { Tabs, Button, Upload, Typography, App, Input, Select, Checkbox, Form, Row, Col, Space, Card, Alert } from 'antd';
import { DeleteOutlined, PlusOutlined, UploadOutlined } from '@ant-design/icons';
import type { UploadFile, UploadProps } from 'antd';

const { Title, Text } = Typography;
const { useApp } = App;
const { Option } = Select;

interface GirlFormProps {
  onSuccess?: () => void;
  isSubmitting: boolean;
  setIsSubmitting: (value: boolean) => void;
  initialData?: any;
  backHref?: string;
}

export default function GirlForm({ onSuccess, isSubmitting, setIsSubmitting, initialData, backHref = '/admin/girls' }: GirlFormProps) {
  const router = useRouter();
  const { message, modal } = useApp();
  // Use ref (not state) so the submit handler always sees the latest intent synchronously.
  const saveModeRef = useRef<'stay' | 'back'>('stay');
  const [formData, setFormData] = useState({
    name: initialData?.name || '',
    firstName: initialData?.firstName || '',
    lastName: initialData?.lastName || '',
    middleNames: initialData?.middleNames || '',
    era: initialData?.era || 3,
    isNew: initialData?.isNew ?? false,
    hasNewPhotos: initialData?.hasNewPhotos ?? false,
    theirMan: initialData?.theirMan ?? false,
    published: initialData?.published ?? false,
    sources: initialData?.sources || '',
    timeline: initialData?.timeline || [],
    images: initialData?.images || [],
    links: initialData?.links || [],
    books: initialData?.books || [],
    biography: initialData?.biography || '',
    alternativeNames: initialData?.alternativeNames || '',
    categories: initialData?.categories || '',
    socialLinks: initialData?.socialLinks || '',
    slug: initialData?.slug || '',
    seo: initialData?.seo || {
      seoTitle: '',
      seoDescription: '',
      seoKeywords: '',
      h1Title: '',
      introText: '',
      ogTitle: '',
      ogDescription: '',
      ogImageUrl: '',
      canonicalUrl: '',
      seoStatus: 'red' as 'red' | 'yellow' | 'green',
      autoGenerated: false,
    },
  });

  // Debug: Log images when initialData changes
  useEffect(() => {
    if (initialData?.images) {
      console.log('Admin: Initial images received:', initialData.images.length, initialData.images);
    }
  }, [initialData]);

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [headshotFileList, setHeadshotFileList] = useState<UploadFile[]>([]);
  const [galleryFileList, setGalleryFileList] = useState<UploadFile[]>([]);
  const [activeTab, setActiveTab] = useState('general');

  // Auto-generate slug from name
  useEffect(() => {
    if (!initialData && formData.name && !formData.slug) {
      setFormData(prev => ({
        ...prev,
        slug: generateSlug(formData.name),
      }));
    }
  }, [formData.name, initialData]);


  const handleChange = (field: string, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Prevent double submission
    if (isSubmitting) {
      return;
    }
    setIsSubmitting(true);
    setErrors({});

    try {
      // Validate links/books: do not allow partially-filled rows to be saved.
      const trim = (v: any) => String(v ?? '').trim();

      const normalizeLinks = (links: any[]) => {
        const normalized = (Array.isArray(links) ? links : []).map((l) => ({
          ...l,
          text: trim(l?.text),
          url: trim(l?.url),
        }));
        const invalidIdx = normalized.findIndex((l) => (l.text && !l.url) || (!l.text && l.url));
        if (invalidIdx !== -1) {
          setActiveTab('sources');
          const rowNum = invalidIdx + 1;
          setErrors({ submit: `Links: row #${rowNum} must have both Link Text and URL (or leave both empty).` });
          setIsSubmitting(false);
          return null;
        }
        // Drop fully-empty rows
        return normalized.filter((l) => l.text || l.url);
      };

      const normalizeBooks = (books: any[]) => {
        const normalized = (Array.isArray(books) ? books : []).map((b) => ({
          ...b,
          title: trim(b?.title),
          url: trim(b?.url),
        }));
        const invalidIdx = normalized.findIndex((b) => (b.title && !b.url) || (!b.title && b.url));
        if (invalidIdx !== -1) {
          setActiveTab('sources');
          const rowNum = invalidIdx + 1;
          setErrors({ submit: `Recommended Books: row #${rowNum} must have both Title and URL (or leave both empty).` });
          setIsSubmitting(false);
          return null;
        }
        // Drop fully-empty rows
        return normalized.filter((b) => b.title || b.url);
      };

      const normalizedLinks = normalizeLinks(formData.links);
      if (normalizedLinks === null) return;
      const normalizedBooks = normalizeBooks(formData.books);
      if (normalizedBooks === null) return;

      const payload: any = {
        ...formData,
        links: normalizedLinks,
        books: normalizedBooks,
      };

      // SEO is saved by SEOFormSectionEnhanced via its own API calls.
      // Avoid overwriting SEO with stale/empty values on the main Save.
      if (initialData?.id) {
        delete payload.seo;
      }

      const url = initialData 
        ? `/api/admin/girls/${initialData.id}`
        : '/api/admin/girls';
      
      const method = initialData ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      const data = await response.json();

      if (!response.ok) {
        if (data.details) {
          setErrors(
            data.details.reduce((acc: Record<string, string>, err: any) => {
              acc[err.path[0]] = err.message;
              return acc;
            }, {})
          );
        } else {
          setErrors({ submit: data.error || 'Failed to save' });
        }
        setIsSubmitting(false);
        return;
      }

      // EDIT: by default stay on the page (so you don't lose context/filters).
      // Provide "Save & Back" for returning to the list.
      if (initialData?.id) {
        message.success('Saved');
        if (saveModeRef.current === 'back') {
          // reset so next save doesn't unexpectedly kick you back
          saveModeRef.current = 'stay';
          if (onSuccess) onSuccess();
          else router.push(backHref);
          return;
        }
        setIsSubmitting(false);
        return;
      }

      // CREATE: keep existing behavior
      if (onSuccess) onSuccess();
      else router.push('/admin/girls');
    } catch (error) {
      console.error('Error saving girl:', error);
      setErrors({ submit: 'An error occurred while saving' });
      setIsSubmitting(false);
    }
  };

  const handleHeadshotUpload: UploadProps['customRequest'] = async ({ file, onSuccess, onError, onProgress }) => {
    if (!initialData?.id) {
      message.warning('Please save the entry first before uploading headshot.');
      onError?.(new Error('Entry not saved'));
      return;
    }

    const formData = new FormData();
    formData.append('headshot', file as File);
    formData.append('actressId', initialData.id.toString());

    try {
      const xhr = new XMLHttpRequest();

      // Track upload progress
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          onProgress?.({ percent });
        }
      });

      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const data = JSON.parse(xhr.responseText);
          message.success(`Headshot uploaded and processed successfully! Dimensions: ${data.width}x${data.height}px`);
          onSuccess?.(data);
          // Reload page to show new headshot
          setTimeout(() => {
            window.location.reload();
          }, 1000);
        } else {
          const error = JSON.parse(xhr.responseText);
          message.error(`Failed to upload headshot: ${error.error || 'Unknown error'}`);
          onError?.(new Error(error.error || 'Upload failed'));
        }
      });

      xhr.addEventListener('error', () => {
        message.error('Error uploading headshot');
        onError?.(new Error('Network error'));
      });

      xhr.open('POST', '/api/admin/headshot/upload');
      xhr.send(formData);
    } catch (error) {
      console.error('Error uploading headshot:', error);
      message.error('Error uploading headshot');
      onError?.(error as Error);
    }
  };

  const handleGalleryImageUpload: UploadProps['customRequest'] = async ({ file, onSuccess, onError, onProgress }) => {
    if (!initialData?.id) {
      message.warning('Please save the entry first before uploading gallery images.');
      onError?.(new Error('Entry not saved'));
      return;
    }

    const formData = new FormData();
    formData.append('images', file as File);
    formData.append('actressId', initialData.id.toString());
    formData.append('type', 'gallery');

    try {
      const xhr = new XMLHttpRequest();

      // Track upload progress
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          onProgress?.({ percent });
        }
      });

      xhr.addEventListener('load', async () => {
        if (xhr.status === 200) {
          const data = JSON.parse(xhr.responseText);
          message.success(`Gallery images uploaded successfully! ${data.images?.length || 1} image(s) processed.`);
          onSuccess?.(data);
          
          // Fetch updated images from the API instead of reloading the page
          if (initialData?.id) {
            try {
              const response = await fetch(`/api/admin/girls/${initialData.id}`);
              if (response.ok) {
                const updatedGirl = await response.json();
                // Update images in formData
                handleChange('images', updatedGirl.images || []);
                // Keep the gallery tab active
                setActiveTab('gallery');
              }
            } catch (error) {
              console.error('Error fetching updated images:', error);
              // Fallback: still update the tab even if fetch fails
              setActiveTab('gallery');
            }
          }
        } else {
          let parsed: any = null;
          try {
            parsed = xhr.responseText ? JSON.parse(xhr.responseText) : null;
          } catch {
            parsed = null;
          }

          const details = String(parsed?.details || parsed?.message || '').trim();
          const errMsgRaw = String(parsed?.error || 'Upload failed').trim();

          // Avoid duplicated "Failed to upload images: Failed to upload images"
          const errMsg =
            details ||
            (errMsgRaw.toLowerCase().startsWith('failed to upload images')
              ? 'Upload failed (server did not provide details)'
              : errMsgRaw);

          message.error(`Failed to upload images: ${errMsg}`);
          onError?.(new Error(errMsg));
        }
      });

      xhr.addEventListener('error', () => {
        message.error('Error uploading gallery images');
        onError?.(new Error('Network error'));
      });

      xhr.open('POST', '/api/admin/images/upload');
      xhr.send(formData);
    } catch (error) {
      console.error('Error uploading gallery images:', error);
      message.error('Error uploading gallery images');
      onError?.(error as Error);
    }
  };

  const tabItems = [
    {
      key: 'general',
      label: 'General Info',
      children: (
        <div className="space-y-4">
          {/* Headshot Upload */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Headshot (Portrait Photo)</Title>
            <div className="flex items-center gap-4">
              {initialData?.headshotUrl && (
                <div className="relative">
                  <img 
                    src={initialData.headshotUrl} 
                    alt="Headshot" 
                    className="w-32 h-40 object-cover border border-gray-300 rounded"
                    onError={(e) => {
                      (e.target as HTMLImageElement).style.display = 'none';
                    }}
                  />
                </div>
              )}
              <div>
                <Upload
                  accept="image/*"
                  customRequest={handleHeadshotUpload}
                  fileList={headshotFileList}
                  onChange={({ fileList }) => {
                    setHeadshotFileList(fileList);
                    // Clear file list after successful upload
                    if (fileList[0]?.status === 'done') {
                      setTimeout(() => {
                        setHeadshotFileList([]);
                      }, 2000);
                    }
                  }}
                  maxCount={1}
                  showUploadList={{
                    showPreviewIcon: false,
                    showRemoveIcon: false,
                  }}
                >
                  <Button icon={<UploadOutlined />}>
                    {initialData?.headshotUrl ? 'Replace Headshot' : 'Upload Headshot'}
                  </Button>
                </Upload>
                <p className="text-xs text-gray-500 mt-2" style={{ fontSize: '12px' }}>
                  Image will be automatically cropped and resized to match existing headshots.
                </p>
              </div>
            </div>
          </div>

          {/* Basic Information */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Basic Information</Title>
            <Row gutter={[16, 16]}>
              <Col xs={24} md={12}>
                <Form.Item
                  label={<Text strong>Name *</Text>}
                  validateStatus={errors.name ? 'error' : ''}
                  help={errors.name}
                >
                  <Input
                    value={formData.name}
                    onChange={(e) => handleChange('name', e.target.value)}
                    required
                  />
                </Form.Item>
              </Col>

              <Col xs={24} md={12}>
                <Form.Item
                  label={<Text strong>Slug *</Text>}
                  validateStatus={errors.slug ? 'error' : ''}
                  help={errors.slug}
                >
                  <Input
                    value={formData.slug}
                    onChange={(e) => handleChange('slug', e.target.value)}
                    required
                  />
                </Form.Item>
              </Col>

              <Col xs={24} md={12}>
                <Form.Item label={<Text>First Name</Text>}>
                  <Input
                    value={formData.firstName}
                    onChange={(e) => handleChange('firstName', e.target.value)}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} md={12}>
                <Form.Item label={<Text>Last Name</Text>}>
                  <Input
                    value={formData.lastName}
                    onChange={(e) => handleChange('lastName', e.target.value)}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} md={12}>
                <Form.Item label={<Text>Middle Names</Text>}>
                  <Input
                    value={formData.middleNames}
                    onChange={(e) => handleChange('middleNames', e.target.value)}
                  />
                </Form.Item>
              </Col>

              <Col xs={24} md={12}>
                <Form.Item label={<Text strong>Era/Decade *</Text>}>
                  <Select
                    value={formData.theirMan ? 'men' : formData.era}
                    onChange={(value) => {
                      if (value === 'men') {
                        setFormData(prev => ({ ...prev, theirMan: true, era: 3 }));
                      } else {
                        setFormData(prev => ({ ...prev, theirMan: false, era: parseInt(value) }));
                      }
                    }}
                    style={{ width: '100%' }}
                  >
                    <Option value={1}>1920s-1930s</Option>
                    <Option value={2}>1940s</Option>
                    <Option value={3}>1950s</Option>
                    <Option value={4}>1960s</Option>
                    <Option value="men">Their Men</Option>
                  </Select>
                </Form.Item>
              </Col>
            </Row>

            {/* Status Checkboxes */}
            <Row gutter={[16, 16]} style={{ marginTop: '16px' }}>
              <Col>
                <Checkbox
                  checked={formData.isNew}
                  onChange={(e) => handleChange('isNew', e.target.checked)}
                >
                  <Text>Is New</Text>
                </Checkbox>
              </Col>

              <Col>
                <Checkbox
                  checked={formData.hasNewPhotos}
                  onChange={(e) => handleChange('hasNewPhotos', e.target.checked)}
                >
                  <Text>Has New Photos</Text>
                </Checkbox>
              </Col>

              <Col>
                <Checkbox
                  checked={formData.published}
                  onChange={(e) => handleChange('published', e.target.checked)}
                >
                  <Text>Published</Text>
                </Checkbox>
              </Col>
            </Row>
          </div>
        </div>
      ),
    },
    {
      key: 'timeline',
      label: 'Timeline Events',
      children: (
        <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
          {formData.timeline.map((event: any, index: number) => (
            <Card key={index} size="small">
              <Row gutter={[16, 16]} align="middle">
                <Col span={2}>
                  <Text type="secondary">#{event.ord || index + 1}</Text>
                </Col>
                <Col span={6}>
                  <Form.Item label={<Text>Date:</Text>} style={{ marginBottom: 0 }}>
                    <Input
                      value={event.date || ''}
                      onChange={(e) => {
                        const newTimeline = [...formData.timeline];
                        newTimeline[index] = { ...event, date: e.target.value };
                        handleChange('timeline', newTimeline);
                      }}
                      placeholder="e.g., 15 May 36"
                      size="small"
                    />
                  </Form.Item>
                </Col>
                <Col span={14}>
                  <Form.Item label={<Text>Event:</Text>} style={{ marginBottom: 0 }}>
                    <SimpleEditor
                      value={event.event || ''}
                      onChange={(value) => {
                        const newTimeline = [...formData.timeline];
                        newTimeline[index] = { ...event, event: value };
                        handleChange('timeline', newTimeline);
                      }}
                      placeholder="Event description"
                      rows={2}
                    />
                  </Form.Item>
                </Col>
                <Col span={2}>
                  <Button
                    type="default"
                    danger
                    size="small"
                    icon={<DeleteOutlined />}
                    onClick={() => {
                      modal.confirm({
                        title: 'Delete Timeline Event',
                        content: 'Are you sure you want to delete this timeline event?',
                        okText: 'Delete',
                        okType: 'danger',
                        onOk: () => {
                          const newTimeline = formData.timeline.filter((_: any, i: number) => i !== index);
                          handleChange('timeline', newTimeline);
                        },
                      });
                    }}
                  >
                    Delete
                  </Button>
                </Col>
              </Row>
            </Card>
          ))}
          <Button
            type="default"
            icon={<PlusOutlined />}
            onClick={() => {
              handleChange('timeline', [...formData.timeline, { date: '', event: '', ord: formData.timeline.length + 1 }]);
            }}
            style={{ marginTop: '8px' }}
          >
            Add Event
          </Button>
        </Space>
      ),
    },
    {
      key: 'sources',
      label: 'Sources/Links',
      children: (
        <div className="space-y-6">
          {/* Sources */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Sources</Title>
            <p className="text-xs text-gray-600 mb-1.5" style={{ fontSize: '11px' }}>
              Use the Bold (B) and Italic (I) buttons to format text. The preview shows how it will appear.
            </p>
            <SimpleEditor
              value={formData.sources}
              onChange={(value) => handleChange('sources', value)}
              placeholder="Enter sources here..."
              rows={4}
            />
          </div>

          {/* Links */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Links</Title>
            <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
              {formData.links.map((link: any, index: number) => (
                <Card key={link.id || index} size="small">
                  <Row gutter={[16, 16]} align="middle">
                    <Col span={2}>
                      <Text type="secondary">#{index + 1}</Text>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>Link Text:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          value={link.text || ''}
                          onChange={(e) => {
                            const newLinks = [...formData.links];
                            newLinks[index] = { ...link, text: e.target.value };
                            handleChange('links', newLinks);
                          }}
                          placeholder="e.g., Filmography"
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>URL:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          type="url"
                          value={link.url || ''}
                          onChange={(e) => {
                            const newLinks = [...formData.links];
                            newLinks[index] = { ...link, url: e.target.value };
                            handleChange('links', newLinks);
                          }}
                          placeholder="https://..."
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={2}>
                      <Button
                        type="default"
                        danger
                        size="small"
                        icon={<DeleteOutlined />}
                        onClick={() => {
                          modal.confirm({
                            title: 'Delete Link',
                            content: 'Are you sure you want to delete this link?',
                            okText: 'Delete',
                            okType: 'danger',
                            onOk: () => {
                              const newLinks = formData.links.filter((_: any, i: number) => i !== index);
                              handleChange('links', newLinks);
                            },
                          });
                        }}
                      >
                        Delete
                      </Button>
                    </Col>
                  </Row>
                </Card>
              ))}
              <Button
                type="default"
                icon={<PlusOutlined />}
                onClick={() => {
                  handleChange('links', [...formData.links, { text: '', url: '', ord: formData.links.length + 1 }]);
                }}
              >
                Add Link
              </Button>
            </Space>
          </div>

          {/* Recommended Books */}
          <div>
            <Title level={4} style={{ marginBottom: '12px' }}>Recommended Books</Title>
            <Space orientation="vertical" size="middle" style={{ width: '100%' }}>
              {formData.books.map((book: any, index: number) => (
                <Card key={book.id || index} size="small">
                  <Row gutter={[16, 16]} align="middle">
                    <Col span={2}>
                      <Text type="secondary">#{index + 1}</Text>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>Book Title:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          value={book.title || ''}
                          onChange={(e) => {
                            const newBooks = [...formData.books];
                            newBooks[index] = { ...book, title: e.target.value };
                            handleChange('books', newBooks);
                          }}
                          placeholder="e.g., Western Women by Boyd Magers"
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={10}>
                      <Form.Item label={<Text>URL:</Text>} style={{ marginBottom: 0 }}>
                        <Input
                          type="url"
                          value={book.url || ''}
                          onChange={(e) => {
                            const newBooks = [...formData.books];
                            newBooks[index] = { ...book, url: e.target.value };
                            handleChange('books', newBooks);
                          }}
                          placeholder="https://..."
                          size="small"
                        />
                      </Form.Item>
                    </Col>
                    <Col span={2}>
                      <Button
                        type="default"
                        danger
                        size="small"
                        icon={<DeleteOutlined />}
                        onClick={() => {
                          modal.confirm({
                            title: 'Delete Book',
                            content: 'Are you sure you want to delete this book?',
                            okText: 'Delete',
                            okType: 'danger',
                            onOk: () => {
                              const newBooks = formData.books.filter((_: any, i: number) => i !== index);
                              handleChange('books', newBooks);
                            },
                          });
                        }}
                      >
                        Delete
                      </Button>
                    </Col>
                  </Row>
                </Card>
              ))}
              <Button
                type="default"
                icon={<PlusOutlined />}
                onClick={() => {
                  handleChange('books', [...formData.books, { title: '', url: '', ord: formData.books.length + 1 }]);
                }}
              >
                Add Book
              </Button>
            </Space>
          </div>
        </div>
      ),
    },
    {
      key: 'seo',
      label: 'SEO & Meta Tags',
      children: (
        <div>
          {initialData?.id && (
            <SEOFormSectionEnhanced
              actressId={initialData.id}
              actressData={{
                name: formData.name,
                firstName: formData.firstName,
                lastName: formData.lastName,
                era: formData.era,
                slug: formData.slug,
                galleryCount: formData.images?.length || 0,
              }}
              initialSEO={formData.seo}
            />
          )}
          {!initialData?.id && (
            <p className="text-xs text-gray-500" style={{ fontSize: '11px' }}>
              Please save the entry first before managing SEO data.
            </p>
          )}
        </div>
      ),
    },
    {
      key: 'gallery',
      label: 'Gallery Images',
      children: (
        <div>
          <div className="flex items-center justify-between mb-4">
            {initialData?.id && (
              <Upload
                accept="image/*"
                multiple
                customRequest={handleGalleryImageUpload}
                fileList={galleryFileList}
                onChange={({ fileList }) => {
                  setGalleryFileList(fileList);
                  // Clear file list after successful upload
                  const allDone = fileList.every(file => file.status === 'done' || file.status === 'error');
                  if (allDone && fileList.length > 0) {
                    setTimeout(() => {
                      setGalleryFileList([]);
                    }, 2000);
                  }
                }}
                showUploadList={{
                  showPreviewIcon: false,
                  showRemoveIcon: true,
                }}
              >
                <Button icon={<UploadOutlined />} type="default">
                  Upload Gallery Images
                </Button>
              </Upload>
            )}
          </div>
          {!initialData?.id && (
            <p className="text-xs text-gray-500 mb-3" style={{ fontSize: '11px' }}>Please save the entry first before uploading gallery images.</p>
          )}
          {formData.images && formData.images.length > 0 ? (
            <div>
              <div className="mb-2 text-sm text-gray-600">
                {formData.images.length} image{formData.images.length !== 1 ? 's' : ''} found
              </div>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {formData.images.map((img: any, index: number) => {
                  const galleryPath = img.url || img.path || '';
                  
                  // If the path is already a full Supabase URL, use it directly
                  // Otherwise, use the thumbnail API with the database path
                  let thumbnailUrl = '';
                  if (galleryPath) {
                    if (galleryPath.startsWith('http://') || galleryPath.startsWith('https://')) {
                      // Already a full URL - use thumbnail API to resize it
                      thumbnailUrl = `/api/images/thumbnail?path=${encodeURIComponent(galleryPath)}&width=200&height=250`;
                    } else {
                      // Database path - use thumbnail API
                      thumbnailUrl = `/api/images/thumbnail?path=${encodeURIComponent(galleryPath)}&width=200&height=250`;
                    }
                  }
                  
                  const handleDeleteImage = async () => {
                    modal.confirm({
                      title: 'Delete Image',
                      content: 'Are you sure you want to delete this image? This action cannot be undone.',
                      onOk: async () => {
                        try {
                          const res = await fetch(`/api/admin/images/${img.id}`, {
                            method: 'DELETE',
                          });

                          if (res.ok) {
                            const newImages = formData.images.filter((i: any) => i.id !== img.id);
                            handleChange('images', newImages);
                            message.success('Image deleted successfully');
                          } else {
                            const error = await res.json();
                            message.error(`Failed to delete image: ${error.error || 'Unknown error'}`);
                          }
                        } catch (error) {
                          console.error('Error deleting image:', error);
                          message.error('Error deleting image');
                        }
                      },
                    });
                  };
                  
                  return (
                    <div key={img.id || index} className="border border-gray-300 p-1.5 bg-white relative">
                      <div className="relative bg-white">
                        {thumbnailUrl ? (
                          <img 
                            src={thumbnailUrl} 
                            alt={`Image ${index + 1}`}
                            className="w-full h-auto block"
                            style={{ backgroundColor: 'transparent' }}
                          />
                        ) : (
                          <div className="w-full h-32 bg-gray-200 flex items-center justify-center text-xs text-gray-500">
                            No image
                          </div>
                        )}
                        <Button
                          size="small"
                          icon={<DeleteOutlined />}
                          onClick={handleDeleteImage}
                          style={{ position: 'absolute', top: '4px', right: '4px', zIndex: 10 }}
                        >
                          Delete
                        </Button>
                      </div>
                      <div className="mt-1.5 text-xs text-gray-600 space-y-0.5" style={{ fontSize: '10px' }}>
                        <div>
                          Gallery: {img.width && img.height ? `${img.width} × ${img.height} px` : 'Unknown size'}
                        </div>
                        {img.hq && (
                          <div className="text-green-600 font-semibold">
                            ✓ HQ Available: {img.hq.width} × {img.hq.height} px ({img.hq.sizeMB} MB)
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="text-sm text-gray-500 py-4">
              No gallery images found. Upload images using the uploader above.
            </div>
          )}
        </div>
      ),
    },
  ];

  return (
    <Card>
      <div style={{ marginBottom: 12 }}>
        <Link href={backHref} style={{ fontSize: 12, color: '#1890ff' }}>
          ← Back to list
        </Link>
      </div>
      <form onSubmit={handleSubmit}>
      <Tabs
        activeKey={activeTab}
        onChange={setActiveTab}
        items={tabItems}
        type="card"
      />

      {/* Error Message */}
      {errors.submit && (
        <Alert
          title={errors.submit}
          type="error"
          showIcon
          closable
          onClose={() => setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors.submit;
            return newErrors;
          })}
        />
      )}

      {/* Submit Buttons */}
      <Space style={{ marginTop: '24px' }}>
        <Button
          htmlType="submit"
          loading={isSubmitting}
          size="large"
          onClick={() => {
            saveModeRef.current = 'stay';
          }}
          style={{ 
            fontWeight: 'bold',
            borderWidth: '2px',
            borderStyle: 'solid',
            borderColor: '#000000',
            backgroundColor: '#f5f5f5',
            color: '#000000'
          }}
        >
          {isSubmitting ? 'Saving...' : 'Save'}
        </Button>

        {initialData?.id && (
          <Button
            htmlType="submit"
            loading={isSubmitting}
            size="large"
            onClick={() => {
              saveModeRef.current = 'back';
            }}
            type="primary"
          >
            Save & Back
          </Button>
        )}
      </Space>
      </form>
    </Card>
  );
}

